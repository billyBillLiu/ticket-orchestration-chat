# app/services/field_prefiller_service.py
from __future__ import annotations
import json
from typing import Dict, Any, List
from app.models.ticket_agent import TicketPlan, TicketItem
from app.services.catalog_service import find_ticket_spec
from app.services.llm_service import llm_service, Message as LLMMessage
from datetime import datetime

# System prompt for field prefilling - focused on filling fields with available options
SYSTEM_PREFILL = """
You are a Ticket Form Field Prefilling Specialist.
Your job is to fill in ticket form fields based on user input, using ONLY the available options provided.

CRITICAL RULES:
- Use ONLY the exact field options provided - do NOT invent new values
- For choice fields: Match user input to the closest available option
- For multi_choice fields: Select multiple options that match the user's intent
- For date fields: Convert relative dates using the current date context
- For boolean fields: Convert yes/no, true/false appropriately
- Leave fields empty if you're not confident about the value
- Do NOT use placeholder text or example values
- ALWAYS include the email field with the provided user email if an email field exists
- The summary field will be automatically generated by the system
- Return ONLY valid JSON - NO comments, NO trailing commas, NO extra text.
- IMPORTANT: The current date is provided ONLY as context for processing relative dates (like "tomorrow", "next week"). Do NOT automatically fill date fields with the current date unless the user explicitly mentions it.

FIELD MATCHING STRATEGIES:
1. Exact match (case insensitive)
2. Partial match (user input contains option or vice versa)
3. Semantic match (use context to find the best option)
4. If no good match, leave the field empty

IMPORTANT FIELD MATCHING RULES:
- For vendor/investor names: Look for company names, abbreviations, or keywords in the user's request
- For rerun types: Look for words like "final", "estimated", "manual", "automatic" in the user's request
- For urgency and priority: Look for words like "urgent", "critical", "high", "medium", "low" in the user's request. Do NOT fill urgency unless the user explicitly mentions urgency.
- For dates: Convert relative dates like "tomorrow", "next week", "july 18" to proper dates using the current date as reference. Do NOT fill date fields unless the user mentions dates in the request.
- For infrastructure types: Look for words like "kubernetes", "lambda", "database", "aws" in the user's request

Return ONLY valid JSON with the filled form data.

EXAMPLE OUTPUT FORMAT:
If the user says "I need a high urgency datadog monitoring setup for kubernetes" and the available fields are:
- urgency: ["critical", "high", "medium", "low"]
- infrastructure_type: ["kubernetes", "lambda", "database", "other aws services"]
- alert_priority: ["P1: Critical", "P2: High", "P3: Medium", "P4: Low", "P5: Info"]

You should return:
{
  "urgency": "high",
  "infrastructure_type": "kubernetes",
  "alert_priority": "P2: High"
}

ANOTHER EXAMPLE:
If the user says "Create a final loan tape for AAA vendor" and the available fields are:
- vendor_name: ["AAA Final Loan Tape", "Bawag Final Loan Tape", "Blackstone Final Loan Tape", ...]
- type_of_rerun: ["final", "estimated"]
- urgency: ["critical", "high", "medium", "low"]

You should return:
{
  "vendor_name": "AAA Final Loan Tape",
  "type_of_rerun": "final"
}
NOTE THESE ARE ONLY EXAMPLES, YOU SHOULD FILL THE FIELDS BASED ON THE USER'S REQUEST.

IMPORTANT: Only include fields that you can confidently fill based on the user's request. Do not include fields that are unclear or not mentioned.
CRITICAL: Do NOT make assumptions or fill fields with default values. Only fill fields when the user provides enough information for them.
"""

async def prefill_ticket_fields_async(ticket_item: TicketItem, user_text: str, user_email: str = None) -> Dict[str, Any]:
    """
    Prefill ticket fields using LLM with full access to field definitions and options.
    
    Args:
        ticket_item: The ticket item to prefill
        user_text: User's original request text
        user_email: User's email (optional)
    
    Returns:
        Dict containing the filled form data
    """
    print(f"ðŸ”§ PREFILLER: Starting field prefilling for {ticket_item.ticket_type}")
    
    # Get the full ticket specification with all field details
    spec = find_ticket_spec(ticket_item.service_area, ticket_item.category, ticket_item.ticket_type)
    if not spec:
        print(f"âŒ PREFILLER: Could not find spec for {ticket_item.ticket_type}")
        return {}
    
    # Build detailed field context with all options
    field_context = build_field_context(spec)
    
    # Add current datetime context
    current_datetime = datetime.now()
    datetime_context = f"\n\nCURRENT DATE AS REFERENCE: {current_datetime.strftime('%Y-%m-%d')}"
    
    # Add user email context if available
    user_context = ""
    if user_email:
        user_context = f"\n\nUSER EMAIL: {user_email}\nThe email field should be automatically filled with this email address."
        
    # Create the prompt with detailed field information
    prompt = f"""
                Ticket Type: {ticket_item.ticket_type}
                Service Area: {ticket_item.service_area}
                Category: {ticket_item.category}

                User Request: "{user_text}"

                This is the catalog context. It Shows all Available Fields and Options:
                {field_context}

                Please fill in the form fields based on the user's request. Return ONLY a JSON object with field names as keys and values as the selected options or filled data.

                IMPORTANT: If there is an "email" field available, you MUST include it with the user's email address: "{user_email}" if provided.

                MATCHING INSTRUCTIONS:
                - Carefully analyze the user's request for keywords that match the available options
                - For vendor/investor fields: Look for company names, abbreviations, or keywords mentioned
                - For rerun types: Look for words like "final", "estimated", "manual" in the request
                - For urgency: Look for urgency indicators in the request. If the user does not mention urgency, do not fill the urgency field.
                - For dates: Convert relative dates to proper format
                - For infrastructure: Look for technology keywords mentioned

                Example output format:
                {{
                "email": "{user_email or "user@example.com"}",
                "urgency": "high",
                "start_date": "2024-01-15",
                "end_date": "2024-01-16",
                "vendor_name": "AAA Final Loan Tape"
                }}
                Note that this is just an example, you should fill the fields based on the user's request. Do NOT use this as a template or use these specific values unless they appear in the user's request.

                Only include fields that you can confidently fill based on the user's request.
                Do NOT fill any fields that cannot be inferenced based on the provided information in the user's request.
                Do NOT fill in any option fields that do not have available options similar to any information in the user's request.
                Do NOT fill in any True or False fields that cannot be inferenced based on the provided information in the user's request.
             """
    
    messages = [
        {"role": "system", "content": SYSTEM_PREFILL + datetime_context + user_context},
        {"role": "user", "content": prompt}
    ]
    
    print(f"ðŸ¤– PREFILLER: Calling LLM for field prefilling")
    try:
        # Convert messages to Message objects
        message_objects = [LLMMessage(**msg) for msg in messages]
        
        # Call LLM with JSON format enforcement
        response = await llm_service.generate_non_streaming_response(
            messages=message_objects,
            model="llama3:8b",
            temperature=0.1,
            max_tokens=2048
        )
        
        raw = response.content
        print(f"ðŸ“¥ PREFILLER: LLM returned raw response: '{raw[:100]}...'")
        
        # Clean up the response - extract JSON
        cleaned_json = extract_json_from_response(raw)
        
        # Parse the JSON
        try:
            form_data = json.loads(cleaned_json)
            print(f"âœ… PREFILLER: Successfully parsed form data: {form_data}")
            
            # Ensure email is set if user_email is provided and email field exists in spec
            if user_email and "email" in [field.get("name") for field in spec.get("fields", [])]:
                form_data["email"] = user_email
                print(f"ðŸ“§ PREFILLER: Ensured email field is set to: {user_email}")
            
            # Post-process form data to improve field matching
            form_data = post_process_form_data(form_data, user_text, spec)
            
            return form_data
        except json.JSONDecodeError as e:
            print(f"âŒ PREFILLER: JSON parsing failed: {e}")
            print(f"Raw content: {raw}")
            return {}
            
    except Exception as e:
        print(f"âŒ PREFILLER: LLM failed: {e}")
        return {}

def build_field_context(spec: Dict[str, Any]) -> str:
    """
    Build a detailed context string describing all fields and their options.
    """
    context_lines = []
    
    for field in spec.get("fields", []):
        field_name = field.get("name", "")
        field_type = field.get("type", "")
        description = field.get("description", "")
        options = field.get("options", [])
        
        context_lines.append(f"\nField: {field_name}")
        context_lines.append(f"Type: {field_type}")
        if description:
            context_lines.append(f"Description: {description}")
        
        if options:
            context_lines.append("Available options:")
            for option in options:
                context_lines.append(f"  â€¢ {option}")
            
            # Add matching hints for common field types
            if field_name in ["vendor_name", "from_investor", "to_recipient", "investor_name"]:
                context_lines.append("  â†’ Look for company names, abbreviations (AAA, BBB), or keywords in user request")
            elif field_name in ["type_of_rerun", "request_type"]:
                context_lines.append("  â†’ Look for words like 'final', 'estimated', 'manual', 'automatic' in user request")
            elif field_name == "urgency":
                context_lines.append("  â†’ Look for urgency words like 'urgent', 'critical', 'high', 'medium', 'low' in user request")
            elif field_name in ["infrastructure_type", "source"]:
                context_lines.append("  â†’ Look for infrastructure words like 'kubernetes', 'lambda', 'database', 'aws' in user request")
        else:
            if field_type == "string":
                context_lines.append("  â€¢ Free text input")
            elif field_type == "rich_text":
                context_lines.append("  â€¢ Rich text input")
            elif field_type == "bool":
                context_lines.append("  â€¢ true/false, yes/no, 1/0")
            elif field_type == "int":
                context_lines.append("  â€¢ Integer number")
            elif field_type == "date":
                context_lines.append("  â€¢ Date in YYYY-MM-DD format or relative dates (today, tomorrow, etc.)")
            elif field_type == "time":
                context_lines.append("  â€¢ Time in HH:MM format")
            elif field_type in ["file", "files"]:
                context_lines.append("  â€¢ File upload")
        
        context_lines.append("")
    
    return "\n".join(context_lines)

def extract_json_from_response(raw: str) -> str:
    """
    Extract JSON from LLM response, handling various formats.
    """
    # Look for JSON code blocks
    if "```json" in raw:
        # Extract JSON from markdown code block
        start = raw.find("```json") + 7
        end = raw.find("```", start)
        if end != -1:
            return raw[start:end].strip()
    elif "```" in raw:
        # Extract JSON from regular code block
        start = raw.find("```") + 3
        end = raw.find("```", start)
        if end != -1:
            return raw[start:end].strip()
    
    # Try to find JSON object boundaries if still not clean
    if not raw.strip().startswith("{"):
        # Look for the first { and last }
        start_brace = raw.find("{")
        end_brace = raw.rfind("}")
        if start_brace != -1 and end_brace != -1 and end_brace > start_brace:
            return raw[start_brace:end_brace + 1]
    
    # If all else fails, return the raw content
    return raw.strip()

def post_process_form_data(form_data: Dict[str, Any], user_text: str, spec: Dict[str, Any]) -> Dict[str, Any]:
    """
    Post-process form data to improve field matching for common patterns.
    """
    user_text_lower = user_text.lower()
    
    # Get field definitions
    fields = spec.get("fields", [])
    
    for field in fields:
        field_name = field.get("name", "")
        field_type = field.get("type", "")
        options = field.get("options", [])
        
        # Skip if field already has a value
        if field_name in form_data and form_data[field_name]:
            continue
            
        # Handle vendor/investor name fields
        if field_name in ["vendor_name", "from_investor", "to_recipient", "investor_name"] and options:
            for option in options:
                option_lower = option.lower()
                # Look for company abbreviations or keywords
                if any(keyword in user_text_lower for keyword in option_lower.split()):
                    form_data[field_name] = option
                    print(f"ðŸ”§ PREFILLER: Post-processed {field_name} = {option}")
                    break
        
        # Handle rerun type fields
        elif field_name in ["type_of_rerun", "request_type"] and options:
            if "final" in user_text_lower and "final" in [opt.lower() for opt in options]:
                form_data[field_name] = "final"
                print(f"ðŸ”§ PREFILLER: Post-processed {field_name} = final")
            elif "estimated" in user_text_lower and "estimated" in [opt.lower() for opt in options]:
                form_data[field_name] = "estimated"
                print(f"ðŸ”§ PREFILLER: Post-processed {field_name} = estimated")
        
        # Handle urgency fields
        elif field_name == "urgency" and options:
            urgency_keywords = {
                "critical": ["critical", "urgent", "emergency"],
                "high": ["high", "urgent", "important"],
                "medium": ["medium", "normal", "standard"],
                "low": ["low", "minor", "non-urgent"]
            }
            
            for urgency_level, keywords in urgency_keywords.items():
                if any(keyword in user_text_lower for keyword in keywords) and urgency_level in [opt.lower() for opt in options]:
                    form_data[field_name] = urgency_level
                    print(f"ðŸ”§ PREFILLER: Post-processed {field_name} = {urgency_level}")
                    break
    
    return form_data

async def prefill_plan_fields_async(plan: TicketPlan, user_text: str, user_email: str = None) -> TicketPlan:
    """
    Prefill all fields in a ticket plan using the specialized field prefiller.
    
    Args:
        plan: The ticket plan to prefill
        user_text: User's original request text
        user_email: User's email (optional)
    
    Returns:
        Updated TicketPlan with prefilled fields
    """
    print(f"ðŸ”§ PREFILLER: Starting plan-wide field prefilling for {len(plan.items)} items")
    
    # Create a copy of the plan to modify
    updated_plan = TicketPlan(
        items=[],
        meta=plan.meta
    )
    
    for i, item in enumerate(plan.items):
        print(f"ðŸ”§ PREFILLER: Prefilling item {i+1}: {item.ticket_type}")
        
        # Prefill fields for this ticket item
        form_data = await prefill_ticket_fields_async(item, user_text, user_email)
        
        # Create updated ticket item with prefilled form data
        updated_item = TicketItem(
            service_area=item.service_area,
            category=item.category,
            ticket_type=item.ticket_type,
            title=item.title,
            description=item.description,
            form=form_data,  # Use the prefilled form data
            labels=item.labels
        )
        
        # Set email if provided
        if user_email and "email" in updated_item.form:
            updated_item.form["email"] = user_email
        
        updated_plan.items.append(updated_item)
    
    print(f"âœ… PREFILLER: Completed field prefilling for all {len(updated_plan.items)} items")
    return updated_plan
